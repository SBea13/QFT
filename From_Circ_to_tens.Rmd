---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.9.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
from numpy import linalg as LA
from ncon import ncon

# importing Qiskit
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.circuit import library as lb
from qiskit.providers.ibmq import least_busy
from qiskit.tools.monitor import job_monitor
from qiskit.visualization import plot_histogram, plot_bloch_multivector
# %config InlineBackend.figure_format = 'svg' # Makes the images look nice
```

```{python}
def cphase_swap(circuit, control, target, phase):
    circuit.cp(phase, control, target)
    circuit.swap(control, target)

    
def qft_circuit(circuit, n):
    """
    Apply the rotations needed for the QFT
        Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    
    """
    if n == 0:
        return circuit
    elif n==1:
        circuit.h(0)
        return circuit
    
    circuit.h(0)
    for i in range(n-1):
        cphase_swap(circuit, i, i+1, 1/2**(i+1))
        
    return qft_circuit(circuit, n-1)
```

```{python}
H = lb.HGate().to_matrix()

def CS(phase):
    temp = lb.CPhaseGate(phase).to_matrix() @ lb.SwapGate().to_matrix()
    return temp

def firstCS():
    H = lb.HGate().to_matrix()
    Cphase = CS(0.5)
    Hx2 = np.kron(H, np.eye(2))
    
    return (Hx2 @ Cphase).reshape(2, 2, 2, 2)
```

```{python}
def apply_MPS_2q_gate(gate, state, q1, q2, s, stol=1e-7):
    # Obtaining informations
    chi = state.shape[0]
    d = state.shape[1]
    
    s_left = s[..., q1-1]
    s_left[s_left < stol] = stol
    s_right= s[..., q1+1]
    s_right[s_right < stol] = stol
    s_curr = s[..., q1]
    # Apply gate to (q1, q2)
    temp = ncon( [ np.diag(s_left), state[..., q1], np.diag(s_curr), state[..., q2], np.diag(s_right), gate],
                     [[-3, 1], [1 , 2, 3], [3, 4],  [4, 5, 6], [6, -4], [2, 5, -1 ,-2]] )
    # SVD decomposition to come back to original structure
    nshape = (d*chi, d*chi)
    utemp, stemp, vhtemp = LA.svd( temp.reshape(nshape),
                                full_matrices=False)
    # truncate to reduced dimension
    chitemp = min(chi, len(stemp))
    utemp = utemp[:, range(chitemp)].reshape( s_right.shape[0], d * chitemp)
    vhtemp = vhtemp[range(chitemp), :].reshape(chitemp * d, chi )
    
    # remove environment weights to form new MPS tensors A and B
    state[..., 0] = (np.diag(1 / s_left) @ utemp).reshape(s_left.shape[0], d, chitemp)
    state[..., 1] = (vhtemp @ np.diag(1 / s_right)).reshape(chitemp, d, chi)

    # new weights
    s_curr = stemp[range(chitemp)] / LA.norm(stemp[range(chitemp)])
    
    return state[...,0:1], s_curr
```

```{python}
def apass(state, sMPS, n):
    
    chi = state.shape[0]
    d = state.shape[1]
    first_Gate = firstCS()
    state[..., 0:1], sMPS[...,0] = apply_MPS_2q_gate(first_Gate, state, 0, 1, sMPS)

    for i in range(1, n-1):
        gate_to_app = CS(1/2**(i+1)).reshape(2, 2, 2, 2)
        state[..., i:i+1], sMPS[...,0] = apply_MPS_2q_gate(gate_to_app, state, i, i+1, sMPS)
    
    return state, sMPS
```

```{python}
def qft_circuit(state, sMPS, n):
    for i in range(n-1):
        state, sMPS = apass(state, sMPS, i)
    
    H = lb.HGate().to_matrix()
    IxH = np.kron( np.eye(2), H).reshape(2, 2, 2, 2)
    state[..., 0:1], sMPS[...,0] = apply_MPS_2q_gate(IxH, state, n-2, n-1, sMPS)
    
    return state, sMPS
```

```{python}
def loc_density_MPS(A, sAB, B, sBA):
    """ Compute the local reduced density matrices from an MPS (assumend to be
    in canonical form)."""

    # recast singular weights into a matrix
    mAB = np.diag(sAB)
    mBA = np.diag(sBA)

    # contract MPS for local reduced density matrix (A-B)
    tensors = [np.diag(sBA**2), A, A.conj(), mAB, mAB, B, B.conj(),
             np.diag(sBA**2)]
    connects = [[3, 4], [3, -3, 1], [4, -1, 2], [1, 7], [2, 8], [7, -4, 5],
              [8, -2, 6], [5, 6]]
    rhoAB = ncon(tensors, connects)

    # contract MPS for local reduced density matrix (B-A)
    tensors = [np.diag(sAB**2), B, B.conj(), mBA, mBA, A, A.conj(),
             np.diag(sAB**2)]
    connects = [[3, 4], [3, -3, 1], [4, -1, 2], [1, 7], [2, 8], [7, -4, 5],
              [8, -2, 6], [5, 6]]
    rhoBA = ncon(tensors, connects)

    return rhoAB, rhoBA

```

```{python}
# initialize tensors
d = 2     # dim of qubit
chi = 5  # order of mps matrix
N = 4
qubit = np.zeros( shape=(chi, d, chi, 1) , dtype=complex)
qubit[0, 0, 0, 0] = 1
s = np.ones(chi) / np.sqrt(chi)  # set trivial initial weights
s = np.expand_dims(s, axis=1)

MPS = np.tile(qubit, N)
sMPS = np.tile(s, N)
```

```{python}

```

```{python}
qft_state, sMPS = qft_circuit(MPS, sMPS, N)
```

```{python}
qft_state
```

```{python}

```

```{python}
MPS.shape
```

```{python}
MPS[..., 3]
```

```{python}

```
