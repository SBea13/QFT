---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.9.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
from numpy import linalg as LA
from ncon import ncon
import tenpy as tp

# importing Qiskit
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.circuit import library as lb
from qiskit.providers.ibmq import least_busy
from qiskit.tools.monitor import job_monitor
from qiskit.visualization import plot_histogram, plot_bloch_multivector
# %config InlineBackend.figure_format = 'svg' # Makes the images look nice
```

```{python}
def cphase_swap(circuit, control, target, phase):
    circuit.cp(phase, control, target)
    circuit.swap(control, target)

    
def qft_circuit(circuit, n):
    """
    Apply the rotations needed for the QFT
        Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    
    """
    if n == 0:
        return circuit
    elif n==1:
        circuit.h(0)
        return circuit
    
    circuit.h(0)
    for i in range(n-1):
        cphase_swap(circuit, i, i+1, 1/2**(i+1))
        
    return qft_circuit(circuit, n-1)
```

```{python}
H = lb.HGate().to_matrix()

def CS(phase):
    temp = lb.CPhaseGate(phase).to_matrix() @ lb.SwapGate().to_matrix()
    return temp

def firstCS():
    H = lb.HGate().to_matrix()
    Cphase = CS(0.5)
    Hx2 = np.kron(H, np.eye(2))
    
    return (Hx2 @ Cphase).reshape(2, 2, 2, 2)
```

```{python}
def apply_MPS_2q_gate(gate, state, q1, q2, s, stol=1e-7):
    # Check dim of gate
    # Obtaining informations
    chi = state.shape[0]
    d = state.shape[1]
    
    s_left = s[..., q1-1]
    s_left[s_left < stol] = stol
    s_right= s[..., q1+1]
    s_right[s_right < stol] = stol
    s_curr = s[..., q1]
    # Apply gate to (q1, q2)
    temp = ncon( [ np.diag(s_left), state[..., q1], np.diag(s_curr), state[..., q2], np.diag(s_right), gate],
                     [[-1, 1], [1 , 2, 3], [3, 4],  [4, 5, 6], [6, -4], [-2, -3, 2, 5]] )
    # SVD decomposition to come back to original structure
    nshape = (d*chi, d*chi)
    utemp, stemp, vhtemp = LA.svd( temp.reshape(nshape),
                                full_matrices=False)
    # truncate to reduced dimension
    chitemp = min(chi, len(stemp))
    utemp = utemp[:, range(chitemp)].reshape( s_right.shape[0], d * chitemp)
    vhtemp = vhtemp[range(chitemp), :].reshape(chitemp * d, chi )
    
    # remove environment weights to form new MPS tensors A and B
    state[..., q1] = (np.diag(1 / s_left) @ utemp).reshape(s_left.shape[0], d, chitemp)
    state[..., q2] = (vhtemp @ np.diag(1 / s_right)).reshape(chitemp, d, chi)

    # Truncation
    s_curr = stemp[range(chitemp)] / LA.norm(stemp[range(chitemp)])
    
    return state[..., q1:q2], s_curr

def apply_MPS_1q_gate(gate, state, q1, stol=1e-7):
    # Check dim of gate
    # Obtaining informations
    chi = state.shape[0]
    d = state.shape[1]

    # Apply gate to (q1)
    temp = ncon( [state[..., q1], gate],
                     [ [-1 , 1, -3], [1, -2] ] )
    state[..., q1] = temp
    
    return state[..., q1]
```

```{python}
def apass(state, sMPS, n):
    
    chi = state.shape[0]
    d = state.shape[1]
    first_Gate = firstCS()
    state[..., 0:1], sMPS[...,0] = apply_MPS_2q_gate(first_Gate, state, 0, 1, sMPS)

    for i in range(1, n-1):
        gate_to_app = CS(1/2**(i+1)).reshape(2, 2, 2, 2)
        state[..., i:i+1], sMPS[...,0] = apply_MPS_2q_gate(gate_to_app, state, i, i+1, sMPS)
    
    return state, sMPS
```

```{python}
def qft_circuit(state, sMPS, n):
    for i in range(n-1):
        state, sMPS = apass(state, sMPS, i)
    
    H = lb.HGate().to_matrix()
    state[..., n-1] = apply_MPS_1q_gate(H, state, n-1)
    
    return state, sMPS
```

```{python}
def from_statevect_to_MPS( statevec, n, chi=0, d=2):
    """
    statevec: ndarray
    n: number of qubit
    chi: bond dimension
    d: dimension of local hilbert space
    """
    Us = []
    #shape = [d]*n
    #state_tens = statevec.reshape( shape )
    
    for i in range(n-1):
        state_tens = state_tens.reshape(d, d**(n-1-i))

        U, S, V1 = LA.svd( state_tens, full_matrices=False)
        Us.append( U )
        state_tens = np.diag(S)@V1
        np.swapaxes(state_tens, 0, 1)
        
    return Us
```

```{python}
# initialize tensors
d = 2     # dim of qubit
chi = 5  # order of mps matrix
N = 4
qubit = np.zeros( shape=(chi, d, chi, 1) , dtype=complex)
qubit[0, 0, 0, 0] = 1
s = np.ones(chi) / np.sqrt(chi)  # set trivial initial weights
s = np.expand_dims(s, axis=1)

MPS = np.tile(qubit, N)
sMPS = np.tile(s, N)
```

```{python}
qft_state, sMPS = qft_circuit(MPS, sMPS, N)
```

```{python}
np.real( qft_state[..., 3] )
```

```{python}
# initialize tensors
d = 2     # dim of qubit
chi = 2  # order of mps matrix
N = 2
qubit = np.zeros( shape=(chi, d, chi, 1) , dtype=complex)
qubit[0, 0, 0, 0] = 1
s = np.ones(chi) / np.sqrt(chi)  # set trivial initial weights
s = np.expand_dims(s, axis=1)

MPS = np.tile(qubit, N)
sMPS = np.tile(s, N)
```

```{python}
H = lb.HGate().to_matrix()
#CNOT = lb.CXGate().to_matrix()
CNOT = np.array( [ [1, 0, 0, 0], 
                   [0, 1, 0, 0], 
                   [0, 0, 0, 1], 
                   [0, 0, 1, 0], 
                ] )
Hx2 = np.kron(H, np.eye(2))
bell = (CNOT@Hx2).reshape(2, 2, 2, 2)

#bell = np.eye(4).reshape(2, 2, 2, 2)
#bell = CNOT.reshape(2, 2, 2, 2)
MPS[..., 0:1], sMPS[...,0] = apply_MPS_2q_gate(bell, MPS, 0, 1, sMPS)

```

```{python}
y = np.zeros(4)
MPS = np.real(MPS)
y[0] = np.trace( MPS[:, 0, :, 0]@MPS[:, 0, :, 1] )
y[1] = np.trace( MPS[:, 1, :, 0]@MPS[:, 0, :, 1] )
y[2] = np.trace( MPS[:, 0, :, 0]@MPS[:, 1, :, 1] )
y[3] = np.trace( MPS[:, 1, :, 0]@MPS[:, 1, :, 1] ) 
y /= np.sqrt( np.sum(y**2) )
print(y)
```

```{python}

```

```{python}

```
