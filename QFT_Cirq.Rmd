---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.9.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import numpy as np
import cirq
import matplotlib.pyplot as plt
```

```{python}
def cphase_and_swap(ctrl, target, phase):
    yield cirq.CZ(ctrl, target) ** phase
    yield cirq.SWAP(ctrl, target)


def qft_circuit_swap(qubits, circuit=[]):
    """
    Build a circuit implementing the QFT algorithm on the given @qubits. The order of @qubits is preserved by SWAP operations.
    Implemented using only local operations, i.e. gates acting on neighbouring qubits.
    Adapted from: https://github.com/quantumlib/Cirq/blob/master/examples/quantum_fourier_transform.py and extended to
    n generic qubits through recursion.
    """
    n = len(qubits)
    assert n > 0, "Number of qubits must be > 0"
    
    if (n == 1):
        circuit.append(cirq.H(qubits[0]))
        return cirq.Circuit(circuit, strategy=cirq.InsertStrategy.EARLIEST)
    else:
        circuit.append(cirq.H(qubits[0]))
        circuit.extend(cphase_and_swap(qubits[i], qubits[i+1], 1/2**(i+1)) for i in range(n-1))
        return qft_circuit_swap(qubits[:n-1], circuit)
```

```{python}
qubits = cirq.LineQubit.range(4)
```

```{python}
circuit = qft_circuit_swap(qubits, [])
print(circuit)
```

```{python}
simulator = cirq.Simulator()
result = simulator.simulate(circuit)
print(np.around(result.final_state_vector, 3))
```
