---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.9.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Qiskit implementation of the QFT

```{python}
import numpy as np
import matplotlib.pyplot as plt

# importing Qiskit
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.circuit import library as lb
from qiskit.providers.ibmq import least_busy
from qiskit.tools.monitor import job_monitor
from qiskit.visualization import plot_histogram, plot_bloch_multivector
# %config InlineBackend.figure_format = 'svg' # Makes the images look nice
```

We first present an example with only $3$ qubits

```{python}
qc = QuantumCircuit(3)
qc.h(2)
qc.cp(np.pi/2, 1, 2) # control phase from qubit 1 to qubit 2
qc.cp(np.pi/4, 0, 2) # CROT from qubit 2 to qubit 0
qc.h(1)
qc.cp(np.pi/2, 0, 1) # CROT from qubit 0 to qubit 1
qc.h(0)
qc.swap(0,2)

qc.draw('mpl')
```

```{python}
def qft_rotations(circuit, n):
    """
    Apply the rotations needed for the QFT
        Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    
    """
    if n == 0: # Exit function if circuit is empty
        return circuit
    n -= 1 # Indexes start from 0, and so arrive to n-1
    circuit.h(n) # Apply the H-gate to the most significant qubit
    for qubit in range(n):
        # For each less significant qubit, we need to do a
        # smaller-angled controlled rotation: 
        circuit.cp(np.pi/2**(n-qubit), qubit, n)
    
    # Since it is an iterative procedure we call the function again, and this time it will be
    # Applied to the (n-2)-th qubit
    qft_rotations(circuit, n)
    
def swap_registers(circuit, n):
    """
    Swap the first and the last qubit, the second and the (n-2)-th qubit and so on,
    to respect the QFT notation
        Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    
    """
    for qubit in range(n//2):
        circuit.swap(qubit, n-qubit-1)


def QFT(circuit, n):
    """
    Apply the quantum fourier transform to the circuit @circuit of @n qubits.
    Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    """
    qft_rotations(circuit, n)
    swap_registers(circuit, n)
    return circuit
    
def inverse_QFT(circuit, n):
    """Does the inverse QFT on the first n qubits in circuit"""
    # First we create a QFT circuit of the correct size:
    qft_circ = qft(QuantumCircuit(n), n)
    # Then we take the inverse of this circuit
    invqft_circ = qft_circ.inverse()
    # And add it to the first n qubits in our existing circuit
    circuit.append(invqft_circ, circuit.qubits[:n])
    return circuit.decompose() # .decompose() allows us to see the individual gates
```

```{python}
qc = QuantumCircuit(6)
QFT(qc, 6)
qc.draw('mpl')
```

```{python}
def cphase_swap(circuit, control, target, phase):
    circuit.cp(phase, control, target)
    circuit.swap(control, target)
    
def qft_circuit(circuit, n):
    """
    Apply the rotations needed for the QFT
        Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    
    """
    if n == 0:
        return circuit
    elif n==1:
        circuit.h(0)
        return circuit
    
    circuit.h(0)
    for i in range(n-1):
        cphase_swap(circuit, i, i+1, 1/2**(i+1))
        
    return qft_circuit(circuit, n-1)

```

```{python}
qc = QuantumCircuit(4, 4)
qc.x(3)
qft_circuit(qc, 4)
#qc.measure(np.arange(0, 3), np.arange(0, 3))
qc.draw('mpl')
```

```{python}
simulator = Aer.get_backend('statevector_simulator')

# Execute and get counts
result = execute(qc, simulator).result()
statevector = result.get_statevector(qc)
#plot_state_city(statevector, title='Bell state')
print(statevector)
```

```{python}
# Select the QasmSimulator from the Aer provider
simulator = Aer.get_backend('qasm_simulator')

# Execute and get counts
result = execute(qc, simulator, shots=10000).result()
```

```{python}
counts = result.get_counts()
plot_histogram(counts, title='Bell-State counts')
```

```{python}
# execute?
```

```{python}

```
