---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.9.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# Visualization
import matplotlib.pyplot as plt
from tqdm import tqdm
from time import time

# Numpy
import numpy as np
from numpy import linalg as LA

# importing Qiskit
from qiskit import QuantumCircuit, execute, Aer
from qiskit.circuit import library as lb
# %config InlineBackend.figure_format = 'svg' # Makes the images look nice

# Tensor networks
import quimb as quimb
from ncon import ncon

from gates import CPHASE
```

# Quimb-qiskit interface

```{python}
# Controlled NOT
CNOT = quimb.controlled('not')

# Hadamard
H = quimb.gen.operators.hadamard()

# SWAP
SWAP = quimb.gen.operators.swap()
# Dictionary of the gates

gates = {'h': H, 
        'cx': CNOT,
        'cp': CPHASE,
        'swap': SWAP}
```

```{python}
def cphase_swap(circuit, control, target, phase):
    circuit.cp(phase, control, target)
    circuit.swap(control, target)
    
def qft_circuit(circuit, n):
    """
    Apply the rotations needed for the QFT
        Parameters:
            circuit : quantum circuit
            n       : int
                number of qubits in @circuit
    
    """
    if n == 0:
        return circuit
    elif n==1:
        circuit.h(0)
        return circuit
    
    circuit.h(0)
    for i in range(n-1):
        cphase_swap(circuit, i, i+1, 1/2**(i+1))
        
    return qft_circuit(circuit, n-1)

```

```{python}
class circ_data():
    """ Class to contain the metadata of a qiskit quantum circuit

    """
    def __init__(self, circ):  
        self.data = [ info for info in circ.data]
        # Gates applied in order
        self.gates = [ qub[0].name for qub in self.data ]
        self.gates_params = [ qub[0].params for qub in self.data ]
        # Indices of application of the gates
        self.indeces = [ self._to_index( qub[1])  for qub in self.data  ]
        # Number of qubits in the circuit
        self.n_qub = circ.num_qubits
        
        
    def _to_index(self, x):
        return [ y.index for y in x ]
    
def MPS_circ(qc, init_state = None, gates=gates, chi=None):
    """ Function to transform a qiskit circuit @qc to a quimb MPS circuit, using the gates @gates
        Parameters:
            qc         : QuantumCircuit
            init_state : String containing the state in computational basis, i.e. '000' or '0011'
                         If None starts from empty state '0'*num_qubits
            gates      : dict qiskit_gate_name: quimb_gate
            chi        : maximum bond dimension. If None it is automatically chosen.
            
        TODO: add auto filling with swap gates if non-local gates are present
    """
    data = circ_data(qc)
    
    if init_state == None:
        init_state = '0' * data.n_qub
    
    MPS = quimb.tensor.MPS_computational_state(init_state, tags = 'psi0')
    
    for gate_name, qub_idx, params in zip( data.gates, data.indeces, data.gates_params):
        qubits = tuple(qub_idx)
        if len(params)==0:
            # Non parametric gates
            MPS.gate_( gates[ gate_name ], qubits, tags=gate_name, max_bond=chi, contract='split-gate') 
        else:
            # Parametric gates
            MPS.gate_( gates[ gate_name ](*params), qubits, tags=gate_name, max_bond=chi, contract='split-gate') 
    
    return MPS
```

# Our functions

```{python}
def print_state(dense_state):
    """
    Prints a @dense_state with kets.
    """
    # quimb to_dense adaptation
    if type( dense_state ) == quimb.core.qarray:
        dense_state = [ pop[0] for pop in dense_state]    
    
    N = int(np.log2(len(dense_state)))
    
    binaries = [bin(i)[2:] for i in range(2**N)]
    binaries = ['0'*(N-len(a)) + a for a in binaries] #Pad with 0s
    
    ket = []
    for i, c in enumerate(dense_state):
        if not np.isclose(np.abs(c), 0.):
            if np.isclose(np.imag(c), 0.):
                if np.isclose(np.real(c), 1.):
                    ket.append('|{}>'.format(binaries[i]))
                else:
                    ket.append('{:.3f}|{}>'.format(np.real(c), binaries[i]))  
            else:
                ket.append('{:.3f}|{}>'.format(c, binaries[i]))
    print(' + '.join(ket))
```

```{python}
def to_full_MPS(dense_state, N, d=2):
    """
    Converts a @dense_state of a @N-body system made by @d-dimensional sites into a Matrix Product State 
    in left-canonical form, with sufficiently sized bonds so that exactness is maintained.
    
    Parameters
    ----------
    dense_state : ndarray of shape (d^N,)
        Input dense state, such that the (i,j,k...) entry in dense_state.reshape([d]*N) is the (i,j,k...) coefficient 
        of the state in the computational basis.
    N : integer > 0
        Number of particles/sites
    d : integer > 0
        Local dimension of each particle/site. For a qubit, d=2.
    
    Returns
    -------
    List of @N tensors containing the left-canonical MPS. The first and last tensors are of order 2 (matrices), while
    all the others are of order 3.
    
     U1 - U2 - U3 - ... - UN 
     |    |    |          |
     
    The index ordering convention is from left-to-right. 
    For instance, the "left" index of U2 is the first, the "bottom" one is the second, and the "right" one is the third.
    """
    
    assert N > 0, "Number of sites must be > 0"
    assert d > 0, "Local dimension must be > 0"
    assert len(dense_state.flatten()) == d**N, "The dense_state must be of dimension d**N"
    
    state_tensor = dense_state.reshape([d] * N) #Reshape into a tensor of order N
    MPS = []
    
    last_svd_dim = 1
    for i in range(N-1):
        U, S, Vh = LA.svd(state_tensor.reshape(last_svd_dim*d, d**(N-(i+1))), full_matrices=False)
        
        state_tensor = (np.diag(S) @ Vh)
        
        if i > 0: #first does not need reshaping
            U = U.reshape(last_svd_dim, d, -1) #reshape to allow the contraction
        
        last_svd_dim = len(S)
        MPS.append(U.copy())
        
        
    MPS.append(state_tensor)
        
    return MPS

def to_dense(MPS):
    """
    Given a list of N tensors @MPS [U1, U2, ..., UN] , representing a Matrix Product State, perform the following contraction:
     U1 - U2 - ... - UN
      |    |          |
    leading to a single tensor of order N, representing a dense state.
    
    The index ordering convention is from left-to-right. 
    For instance, the "left" index of U2 is the first, the "bottom" one is the second, and the "right" one is the third.
    
    Parameters
    ----------
    MPS : list of ndarrays
        List of tensors. First and last should be of order 2, all the others of order 3. 
        The last dimension of MPS[i] should be the same of the first dimension of MPS[i+1], for all i.
    
    Returns
    -------
    ndarray of shape ([d] * N)
    N-order tensor representing the dense state.
    """
    
    #TODO add assertions
    
    N = len(MPS)
    first_indices  = [-1, 1]
    middle_indices = [[i, -(i+1), i+1] for i in range(1,N-1)]
    last_indices   = [N-1, -N]
    connect_list = [first_indices, *middle_indices, last_indices]
    
    return ncon(MPS, connect_list)

#Now, let's fix a maximum bond dimension chi:

def to_approx_MPS(dense_state, N, d=2, chi=2):
    """
    Converts a @dense_state of a @N-body system made by @d-dimensional sites into a Matrix Product State 
    in left-canonical form, with the size of links bounded by @chi.
    
    
    
    Parameters
    ----------
    dense_state : ndarray of shape (d^N,)
        Input dense state, such that the (i,j,k...) entry in dense_state.reshape([d]*N) is the (i,j,k...) coefficient 
        of the state in the computational basis.
    N : integer > 0
        Number of particles/sites
    d : integer > 0
        Local dimension of each particle/site. For a qubit, d=2.
    chi : integer > 0
        Maximum bond dimension
    
    Returns
    -------
    List of @N tensors containing the left-canonical MPS. The first and last tensors are of order 2 (matrices), while
    all the others are of order 3. The shapes are not fixed, but they are (a_i, d, a_{i+1}), with a_i, a_{i+1} <= chi 
    for the order 3 tensors, and (d, a_1) or (a_{N-1}, d) for the order 2 tensors at the boundaries.
    
     U1 - U2 - U3 - ... - UN 
     |    |    |          |
     
    The index ordering convention is from left-to-right. 
    For instance, the "left" index of U2 is the first, the "bottom" one is the second, and the "right" one is the third.
    
    Examples
    --------
    For d=2, N=7 and chi=5, the tensor network is as follows:
     U1 -2- U2 -4- U3 -5- U4 -5- U5 -4- U6 -2- U7
     |      |      |      |      |      |      |
    where -x- denotes the bounds' dimension (all the "bottom-facing" indices are of dimension d=2). Thus, the shapes
    of the returned tensors are as follows:
       U1       U2          U3         U4        U5         U6        U7
    [(2, 2), (2, 2, 4), (4, 2, 5), (5, 2, 5), (5, 2, 4), (4, 2, 2), (2, 2)]
    """
    
    assert N > 0, "Number of sites must be > 0"
    assert d > 0, "Local dimension must be > 0"
    assert len(dense_state.flatten()) == d**N, "The dense_state must be of dimension d**N"
    
    state_tensor = dense_state.reshape([d] * N) #Reshape into a tensor of order N
    MPS = []
    
    last_svd_dim = 1
    for i in range(N-1):
        U, S, Vh = LA.svd(state_tensor.reshape(last_svd_dim * d, d**(N-(i+1))), full_matrices=False)
        
        #Truncation
        U  = U[...,:chi]    #shape is (d...d,chi)
        Vh = Vh[:chi, ...]  #shape is (chi, d...d)
        state_tensor = (np.diag(S[:chi]) @ Vh)
        
        if i > 0: #first does not need reshaping
            U = U.reshape(min(last_svd_dim, chi), d, -1) #reshape to allow the contraction
            
        MPS.append(U.copy())
        
        last_svd_dim = len(S) if len(S) < chi else chi
        
    MPS.append(state_tensor)
        
    return MPS
```

```{python}
#Helper functions
def right_contract(states):
    """
    Given the N right-most states of a MPS, computes their contraction with themselves, as follows:
    
    - o  -  o  -  o  -  o
      |     |     |     |
    - o.H - o.H - o.H - o.H
    
    Returns a order 2 tensor.
    """
    #Add np.conjugate (when we will use complex numbers)
    
    N = len(states)
    
    #Numbering of indices follows "diagonals from top-left to bottom-right". See:
    #-2 -  o -3- o -6- o -9-  o
    #     1|     |4    |7     |10
    #-1 -  o -2- o -5- o -8-  o
    
    top_indices = 3 * np.arange(1,N)
    bottom_indices = top_indices - 1
    
    top_indices = np.insert(top_indices, 0, -2)
    bottom_indices = np.insert(bottom_indices, 0, -1)
    
    middle_indices = 3 * np.arange(1, N+1) - 2
    
    top_connections = [[top_indices[i], middle_indices[i], top_indices[i+1]] for i in range(N-1)] + [[top_indices[-1], middle_indices[-1]]]
    bottom_connections = [[bottom_indices[i], middle_indices[i], bottom_indices[i+1]] for i in range(N-1)] + [[bottom_indices[-1], middle_indices[-1]]]

    #print(top_connections, bottom_connections)
    
    conj_states = [np.conjugate(s) for s in states]
    return ncon(states + conj_states, top_connections + bottom_connections)

def left_contract(states):
    """
    Given the N left-most states of a MPS, computes their contraction with themselves, as follows:
    
    o  -  o  -  o  -  o   -
    |     |     |     |
    o.H - o.H - o.H - o.H -
    
    Returns a order 2 tensor.
    """
    #Add np.conjugate (when we will use complex numbers)

    
    #Convention is the following (idk if it's the most efficient...)
    #e.g. for N=4
    # U1 -2- U2 -5- U3 -8- U4 - (-1)
    # |1     |4     |7     |10
    # U1 -3- U2 -6- U3 -9- U4 - (-2)
    #Basically, the contracted indices follow the order of "diagonals" from the bottom-left to the top-right.
    #Start with the first connection, which links U1 to U1.H. Now the "top-right" is between U1 and U2.
    #Now restart from the next connection at the bottom, which links U1 and U2. Going to the "top-right" we see U2 - U2.H, and then
    #U2-U3, and so on.
    
    N = len(states) #Number of tensors to be contracted
    
    if (N == 1):
        state = states[0]
        return ncon([state, state], [[1, -1], [1, -2]])
    
    #Read indices "by row"
    bottom_indices = 3 * (np.arange(N)+1)
    top_indices = bottom_indices - 1
    middle_indices = bottom_indices - 2

    #Free indices
    top_indices[-1] = -1
    bottom_indices[-1] = -2 

    top_connections = [[1,2]] + [[top_indices[i], middle_indices[i+1], top_indices[i+1]] for i in range(N-1)]
    bottom_connections = [[1,3]] + [[bottom_indices[i], middle_indices[i+1], bottom_indices[i+1]] for i in range(N-1)]

    conj_states = [np.conjugate(s) for s in states]
    return ncon(states + conj_states, top_connections + bottom_connections) 
    #Here we work with Python lists, so the + is not elementwise addition, but concatenation of arrays!
    
from copy import deepcopy

def apply_two_qubit_gate(gate_matrix, pos, state):
    """
    Apply a 2-qubit gate specified by the unitary matrix @gate_matrix to qubits at sites (@pos, @pos+1)
    for a MPS @state.
    """
    
    N = len(state)
    state = deepcopy(state) #avoid modifying the original list
    
    gate = np.array(gate_matrix.reshape(2,2,2,2)) #Reshape gate matrix to 4-order tensor

    assert pos < N-1, f"Trying to apply 2-qubit gate to sites ({pos},{pos+1}), but {pos+1} does not exist"

    left_tens = np.array(state[pos])
    right_tens = np.array(state[pos+1])

    #Check boundaries
    #A tensor is at a boundary if it has order 2
    left_is_boundary = len(left_tens.shape) == 2
    right_is_boundary = len(right_tens.shape) == 2
    
    
    #---Contraction with gate---#
    gate_contraction_list = [[-2,-3,1,3], [-1,1,2], [2,3,-4]]

    if left_is_boundary:
        gate_contraction_list[1].pop(0) #Remove free index of left_tens
    if right_is_boundary:
        gate_contraction_list[2].pop(-1) #Remove free index of right_tens

    gate_contracted = ncon([gate, left_tens, right_tens], gate_contraction_list)

    
    #---Set gate_contracted to center of orthogonality---#

    #Compute density matrices of left/right branches
    if not left_is_boundary:
        rho_left = left_contract(state[:pos])

        #Then we diagonalize it
        eigenval, eigenvec = LA.eigh(rho_left)

        #Mask out 0 eigenvalues to avoid dividing by 0
        mask = eigenval > 0
        eigenval = eigenval[mask]
        eigenvec = eigenvec[:, mask]

        sqrt_eigenval = np.sqrt(abs(eigenval))
        X = eigenvec @ np.diag(sqrt_eigenval) @ np.conjugate(eigenvec.T)
        Xinv = eigenvec @ np.diag(1./sqrt_eigenval) @ np.conjugate(eigenvec.T)

        #Absorb X and Xinv into the tensors
        gate_contraction_indices = [1, -2, -3, -4]

        if right_is_boundary:
            gate_contraction_indices.pop(-1)

        #print(X.shape)
        gate_contracted = ncon([X, gate_contracted], [[-1,1], gate_contraction_indices])

        left_boundary = state[pos-1]
        left_connection_indices = [-1, -2, 1]

        if len(left_boundary.shape) == 2: #if this qubit is at the left boundary
            left_connection_indices = [-1, 1]

        state[pos-1] = ncon([left_boundary, Xinv], [left_connection_indices, [1,-3]])

    if not right_is_boundary:
        rho_right = right_contract(state[pos+2:])

        #Then we diagonalize it
        eigenval, eigenvec = LA.eigh(rho_right)

        #Mask out 0 eigenvalues to avoid dividing by 0
        mask = eigenval > 0
        eigenval = eigenval[mask]
        eigenvec = eigenvec[:, mask]

        sqrt_eigenval = np.sqrt(abs(eigenval))
        X = eigenvec @ np.diag(sqrt_eigenval) @ np.conjugate(eigenvec.T)
        Xinv = eigenvec @ np.diag(1./sqrt_eigenval) @ np.conjugate(eigenvec.T)

        #Absorb X and Xinv into the tensors
        gate_contraction_indices = [-1, -2, -3, 1]

        if left_is_boundary:
            gate_contraction_indices = [-1, -2, 1]

        gate_contracted = ncon([gate_contracted, X], [gate_contraction_indices, [1, -4]])

        right_boundary = state[pos+2]
        right_connection_indices = [1, -2, -3]

        if len(right_boundary.shape) == 2: #if this qubit is at the left boundary
            right_connection_indices = [1, -2]

        state[pos+2] = ncon([Xinv, right_boundary], [[-1, 1], right_connection_indices])
    
    #---Split to MPS---#
    #Dimensions for the SVD
    chi_left  = 1
    chi_right = 1

    if left_is_boundary:
        d = left_tens.shape[0]
    else:
        chi_left = left_tens.shape[0]
        d = left_tens.shape[1]

    if not right_is_boundary:
        chi_right = right_tens.shape[-1]

    #---Perform SVD---#
    U, S, Vh = LA.svd(gate_contracted.reshape(chi_left * d, d * chi_right), full_matrices=False)

    if left_is_boundary:
        state[pos] = U
    else:
        state[pos] = U.reshape(chi_left, d, -1)    

    right_tens = np.diag(S) @ Vh
    if right_is_boundary:
        state[pos+1] = right_tens
    else:
        state[pos+1] = right_tens.reshape(-1, d, chi_right)
    
    return state

# result = to_dense(state).flatten()

# print_state(result)
```

```{python}
def apply_one_qubit_gate(gate, pos, state):
    """
    Applies a one qubit gate @gate to the site @pos of the MPS @state.
    """
    
    state = deepcopy(state)
    
    contraction_indices = [-1 , 1, -3]
    
    if (pos == 0): #site at the left boundary
        contraction_indices.pop(0)
    if (pos == len(state)-1): #site at the right boundary
        contraction_indices.pop(-1)
        
    # Apply gate to (q1)
    temp = ncon( [state[pos], gate],
                     [ contraction_indices, [1, -2] ] )
    state[pos] = temp
    
    return state
```

```{python}
def cphase_and_swap(phase):
    cphase = np.array(quimb.controlled('z')) ** phase
    swap = np.array(quimb.swap())
    
    return swap @ cphase

def qft_circuit_swap(state, N, verbosity=False):
    """
    Computes the QFT of a MPS @state with @N qubits.
    """
    
    H = np.array(quimb.hadamard())
    for pos in range(N):
        if verbosity: print("H(0)")
        state = apply_one_qubit_gate(H, 0, state)
        
        for i in range(N-pos-1):
            if verbosity: print(f"CZS(({i},{i+1}), {1/2**(i+1)})")
            state = apply_two_qubit_gate(cphase_and_swap(1/2**(i+1)), i, state) #to (i, i+1)
    
    return state
```

```{python}
#Example 

N=2
state = np.zeros(2**N)
state[0] = 1

print("Initial state:")
print_state(state)

state = state.reshape([2] * N)
state = to_full_MPS(state, d=2, N=N) #convert to MPS

H = np.array(quimb.hadamard())
state1 = apply_one_qubit_gate(H, 0, state)

print("Hadamard to pos=0")
print_state(to_dense(state1).flatten())

CNOT = quimb.controlled('not')

pos = 0
state2 = apply_two_qubit_gate(CNOT, pos, state1)

print(f"Apply CNOT to sites: ({pos}, {pos+1})")
state2 = to_dense(state2).flatten()
print("New state:")
print_state(state2)
```

## Tests to do:

- Confront performances and results between quimb and our implementation [DONE]
- Check maximum number of qubit simulabili [DONE AGAIN]
- Check performance with bond dimension [when implemented]

```{python}

```

### Quimb

```{python}
N_qub = np.arange(4, 17, dtype=int)
total_time_quimb = np.zeros(2)

for n_qub in tqdm(N_qub):
    time_quimb = []
    for _ in range(10):
        start = time()
        qc = QuantumCircuit(n_qub)
        qft_circuit(qc, n_qub)
        psi0 = MPS_circ(qc)
        psi_dense = psi0.to_dense()
        time_quimb.append( time()-start )
    total_time_quimb = np.vstack( (total_time_quimb, [np.mean(time_quimb), np.std(time_quimb) ]) )
    
total_time_quimb = total_time_quimb[1:,:]
```

### Manual

```{python}
total_time_manual = np.zeros(2)
N_qub_m = np.arange(4, 12, dtype=int)

for N in tqdm(N_qub_m):
    time_manual = []
    for _ in range(10):
        start = time()
        state = np.zeros(2**N)
        state = to_full_MPS(state, d=2, N=N)
        result = qft_circuit_swap(state, N)
        result = to_dense(result).flatten()
        time_manual.append( time()-start )
        
    total_time_manual = np.vstack( (total_time_manual, [np.mean(time_manual), np.std(time_manual) ]) )
    
total_time_manual = total_time_manual[1:,:]
```

```{python}
plt.plot(N_qub, total_time_quimb[:, 0], color='navy', label='quimb')
plt.fill_between(N_qub, total_time_quimb[:,0]-total_time_quimb[:,1], total_time_quimb[:,0]+total_time_quimb[:,1],
                color='cyan', alpha=0.5)

plt.plot(N_qub_m, total_time_manual[:, 0], 'r--', label='manual')
plt.fill_between(N_qub_m, total_time_manual[:,0]-total_time_manual[:,1], total_time_manual[:,0]+total_time_manual[:,1],
                color='pink', alpha=0.5)

plt.ylabel('Time [s]')
plt.xlabel('Number of qubits')
plt.title('Time scaling for QFT circuit')
plt.legend(loc='best')
#plt.yscale('log')
#plt.ylim(0, 1.5)
plt.show()
```

```{python}

```
