---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.9.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# Visualization
import matplotlib.pyplot as plt
from tqdm import tqdm
from time import time
from copy import deepcopy

# Numpy
import numpy as np
from numpy import linalg as LA

# importing Qiskit
from qiskit import QuantumCircuit, execute, Aer
from qiskit.circuit import library as lb
# %config InlineBackend.figure_format = 'svg' # Makes the images look nice

# Tensor networks
import quimb as quimb
from ncon import ncon

from helper import print_state, right_contract, left_contract
from helper import to_full_MPS, to_dense, to_approx_MPS

from manual import apply_two_qubit_gate_full, max_bond_dimension, apply_two_qubit_gate, apply_one_qubit_gate

from gates import CPHASE, cphase_swap_qiskit, cphase_swap_quimb

from circuit import qft_circuit_qiskit, qft_circuit_swap, circ_data, MPS_circ
```

# Quimb-qiskit interface

```{python}
# Controlled NOT
CNOT = quimb.controlled('not')

# Hadamard
H = quimb.gen.operators.hadamard()

# SWAP
SWAP = quimb.gen.operators.swap()
# Dictionary of the gates

gates = {'h': H, 
        'cx': CNOT,
        'cp': CPHASE,
        'swap': SWAP}
```

## Tests to do:

- Confront performances and results between quimb and our implementation [DONE]
- Check maximum number of qubit simulabili [DONE AGAIN]
- Check performance with bond dimension [when implemented]

```{python}
#Example 

N=2
state = np.zeros(2**N)
state[0] = 1

print("Initial state:")
print_state(state)

state = state.reshape([2] * N)
state = to_full_MPS(state, d=2, N=N) #convert to MPS

H = np.array(quimb.hadamard())
state1 = apply_one_qubit_gate(H, 0, state)

print("Hadamard to pos=0")
print_state(to_dense(state1).flatten())

CNOT = quimb.controlled('not')

pos = 0
state2 = apply_two_qubit_gate_full(CNOT, pos, state1)

print(f"Apply CNOT to sites: ({pos}, {pos+1})")
state2 = to_dense(state2).flatten()
print("New state:")
print_state(state2)
```

### Quimb

```{python}
N_qub = np.arange(4, 17, dtype=int)
total_time_quimb = np.zeros(2)

for n_qub in tqdm(N_qub):
    time_quimb = []
    for _ in range(10):
        start = time()
        qc = QuantumCircuit(n_qub)
        qft_circuit_qiskit(qc, n_qub)
        psi0 = MPS_circ(qc, gates)
        psi_dense = psi0.to_dense()
        time_quimb.append( time()-start )
    total_time_quimb = np.vstack( (total_time_quimb, [np.mean(time_quimb), np.std(time_quimb) ]) )
    
total_time_quimb = total_time_quimb[1:,:]
```

### Manual

```{python}
total_time_manual = np.zeros(2)
N_qub_m = np.arange(4, 12, dtype=int)

for N in tqdm(N_qub_m):
    time_manual = []
    for _ in range(10):
        start = time()
        state = np.zeros(2**N)
        state = to_full_MPS(state, d=2, N=N)
        result = qft_circuit_swap(state, N)
        result = to_dense(result).flatten()
        time_manual.append( time()-start )
        
    total_time_manual = np.vstack( (total_time_manual, [np.mean(time_manual), np.std(time_manual) ]) )
    
total_time_manual = total_time_manual[1:,:]
```

```{python}
plt.plot(N_qub, total_time_quimb[:, 0], color='navy', label='quimb')
plt.fill_between(N_qub, total_time_quimb[:,0]-total_time_quimb[:,1], total_time_quimb[:,0]+total_time_quimb[:,1],
                color='cyan', alpha=0.5)

plt.plot(N_qub_m, total_time_manual[:, 0], 'r--', label='manual')
plt.fill_between(N_qub_m, total_time_manual[:,0]-total_time_manual[:,1], total_time_manual[:,0]+total_time_manual[:,1],
                color='pink', alpha=0.5)

plt.ylabel('Time [s]')
plt.xlabel('Number of qubits')
plt.title('Time scaling for QFT circuit')
plt.legend(loc='best')
#plt.yscale('log')
#plt.ylim(0, 1.5)
plt.show()
```

```{python}

```
